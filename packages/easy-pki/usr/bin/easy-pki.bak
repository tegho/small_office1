#!/bin/bash


function errorinfo() {
  echo "$1" >&2
}


function helpexit() {
  local me=$(basename "$0")
  cat << HELP
Encrypted PKI manager.
$me --help
  Print help and exit.
  Exit code is 1.

BASIC OPERATIONS:
  $me is able to create encrypted container, mount and unmount it, mount-execute-unmount in one step.
  Actual PKI is based on easy-rsa inside the container. It goes interactively while no passwords are given
  in environment variables (check for examples).
  First parameter always must be a cryptfile.

$me cryptfile --init [--size size]
  Create a new container in the cryptfile. File can not exist.
  Then copy /usr/share/easy-rsa inside, tune vars and openssl config.
  Then runs "easyrsa init-pki" inside the container.
  Size in MiB for an ext4 filesystem in the container. Minimum 8 MiB (3.5 data + journal).
  Default size is 12 MiB (7.3 data + journal). Actual container is always 16 MiB bigger than size.
  If succeed exit code is 0 and stdout is a line with base64 container key.
  Now it is a good time to modify configs if needed before any keys manipulations.

$me cryptfile --open
  First tries to close container if it is already opened. Exits if failed.
  Then open container from cryptfile and mount it in temp directory with permission 700.
  If environment variable CONTAINER_KEY is not set, then asks container key interactively.
  If succeed exit code is 0 and stdout is a name of the mountpoint.
  Dont forget to close it!

$me cryptfile --close
  Tries to close container if it is already opened.
  If succeed exit code is 0.

$me cryptfile --exec --cmd cmdline
  First tries to close container if it is already opened. Exits if failed.
  Then open container from cryptfile and mount it in temp directory with permission 700. Exits if failed.
  If environment variable CONTAINER_KEY is not set, then asks container key interactively.
  Then runs cmdline in a current shell. Environment variable SECD is a mountpoint. Current dir for
  the cmdline is the mountpoint.
  Then closes container.
  Exit code is 0 if all steps succeded and cmdline exit code is 0.

SHORTCUTS:
  $me is just a wrap for easy-rsa, so shortcuts just help to make a shorter commands for some common cases and do some file management.

$me cryptfile --newreq [--cn CN] --internalname internalname [--nopass]
  Shortcut for creating a new cert request:
  $me cryptfile easy-rsa/easyrsa --req-cn="CN" gen-req internalname [nopass]
  If CN is not specified then cn=internalname.
  Internalname is a filename of key/request/cert without extension.
  The main purpose is to check if internalname is available and to protect existing keys or certs from overwriting.
  Requests which dont have key or cert will be overwritten.
  Exit code is 0 if filename is available and request is generated successfully.

$me cryptfile --loadreq --file filename [--internalname internalname]
  Shortcut for loading external cert request inside container.
  The main purpose is to check if filename have same available internalname and to protect existing keys from overwriting.
  Requests which dont have key or cert will be overwritten.
  Exit code is 0 if same internalname is available and request is loaded successfully.

$me cryptfile --signserver --internalname internalname --dns dns [--userid userid]
  Shortcut for signing cert request inside container.
  Dns must be valid in order to IPSEC work.
  If userid is not specified then userid=internalname.
  The main purpose is to add dns and email(rfc822Name) in subject-alt-name. Correct DNS is important if you run ipsec server and email is being used as a some text tag.
  Exit code is 0 if same signed successfully.

$me cryptfile --signclient --internalname internalname [--dns dns] [--userid userid]
  Shortcut for signing cert request inside container.
  If userid is not specified then userid=internalname.
  The main purpose is to add dns and email(rfc822Name) in subject-alt-name. Correct DNS is important if you run ipsec server and email is being used as user uniq identificator by ipsec and ovpn servers.
  Exit code is 0 if same signed successfully.


EXAMPLES:
  Create new container
  key64=\$($me ./cryptfile --init) && echo \$key64 > ./password

  Generate CA
  echo "SecretPassword" > "./ca_passwd"
  EASYRSA_PASSIN="pass:\$(cat ./ca_passwd)" EASYRSA_PASSOUT="\$EASYRSA_PASSIN" CONTAINER_KEY="\$(cat ./password)" easy-pki ./cryptfile easy-rsa/easyrsa --req-cn="myCA" build-ca
  or for interactive mode
  easy-pki ./cryptfile easy-rsa/easyrsa --req-cn="myCA" build-ca

  Generate new CRL
  EASYRSA_PASSIN="pass:\$(cat ./ca_passwd)" CONTAINER_KEY="\$(cat ./password)" easy-pki ./cryptfile easy-rsa/easyrsa gen-crl

  Generate cert request for client or server with unencrypted private key
  EASYRSA_PASSIN="pass:\$(cat ./ca_passwd)" CONTAINER_KEY="\$(cat ./password)" easy-pki ./cryptfile easy-rsa/easyrsa --req-cn="servername1" gen-req server1 nopass

  Generate cert request for client or server with encrypted private key
  EASYRSA_PASSIN="pass:\$(cat ./ca_passwd)" CONTAINER_KEY="\$(cat ./password)" easy-pki ./cryptfile easy-rsa/easyrsa --req-cn="ivanov ivan" gen-req user_ivanov

  Sign 
  easy-rsa/easyrsa --subject-alt-name='DNS:server1.dns.com,email:server1' sign-req server fserver1
easy-rsa/easyrsa --subject-alt-name='DNS:server3.dns.com,email:server3,otherName:2.1.0.1.1;UTF8:useful data' sign-req server fserver3



  Open container for manual maintance
  CONTAINER_KEY="\$(cat ./password)" $me ./cryptfile --open

  Close container
  $me ./cryptfile --close

  Check the container for a free space
  CONTAINER_KEY="\$(cat ./password)" $me ./cryptfile "df -h \\\$SECD"

  Print easy-rsa\\vars piped and filtered
  CONTAINER_KEY="\$(cat ./password)" $me ./cryptfile "cat easy-rsa/vars|sed -n '/^[\t ]*#/d;/^[\t ]*$/d;p'"

HELP
  exit 1
}


function open_container() {
  local pki_container="$1"
  local container_key_txt="$2"
  local crypto_dir
  local container_name

  if [ -z "$pki_container" ]; then
    errorinfo "($FUNCNAME) Set a filename of container"
    return 1
  fi

  pki_container=$(realpath -ms -- "$pki_container")
  if [ ! -f "$pki_container" ]; then
    errorinfo "($FUNCNAME) Container does not exists: $pki_container"
    return 1
  fi

  if ! container_name=$(openssl rand -hex 8); then
    rm -f "$pki_container"
    errorinfo "($FUNCNAME) Openssl rand error"
    return 1
  fi

  container_key_txt="$CONTAINER_KEY"
  [ -z "$container_key_txt" ] && read -sp "Key (base64) for the container: " container_key_txt
  if [ -z "$container_key_txt" ]; then
    errorinfo "($FUNCNAME) Container key is empty"
    return 1
  fi

  if ! echo $container_key_txt | base64 -d | cryptsetup open --type luks --key-file - "$pki_container" "$container_name" ; then
    errorinfo "($FUNCNAME) Cannot open container: $pki_container"
    return 1
  fi

  crypto_dir=$(mktemp -d /tmp/cptXXXXXX) && \
    rm -rf "$crypto_dir" && \
    mkdir -p "$crypto_dir" && \
    chmod 700 "$crypto_dir"
  if [ $? -ne 0 ]; then
    cryptsetup close "$container_name"
    errorinfo "($FUNCNAME) Cannot create temp mountpoint: $crypto_dir"
    return 1
  fi

  if ! mount -o sync "/dev/mapper/$container_name" "$crypto_dir"; then
    rm -rf "$crypto_dir"
    cryptsetup close "$container_name"
    errorinfo "($FUNCNAME) Cannot mount container $pki_container to $crypto_dir"
    return 1
  fi

  if ! chmod 700 "$crypto_dir" ; then
    umount -l "$crypto_dir"
    rm -rf "$crypto_dir"
    cryptsetup close "$container_name"
    errorinfo "($FUNCNAME) Cannot set permissions after mount."
    return 1
  fi

  echo "$crypto_dir"
  return 0
}


function close_container() {
  local pki_container="$1"
  local loopname
  local container_name
  local crypto_dir
  local ret=0

  if [ -z "$pki_container" ]; then
    errorinfo "($FUNCNAME) Set a filename of container"
    return 1
  fi

  pki_container=$(realpath -ms -- "$pki_container")
  if [ ! -f "$pki_container" ]; then
    errorinfo "($FUNCNAME) Container does not exists: $pki_container"
    return 1
  fi

  # if same container opened multiple times
  losetup -j "$pki_container" | cut -d ':' -f1 | while read loopname; do
    loopname=$(basename "$loopname")

    # if multiple devices associated with this loop
    dmsetup deps -o devname | grep "($loopname)" | cut -d ':' -f1 | while read container_name; do
      sync "/dev/mapper/$container_name" || sleep 5

      # if mounted multiple times
      lsblk "/dev/mapper/$container_name" -no mountpoint | while read crypto_dir; do

        if [ -n "$crypto_dir" ]; then
          umount -l "$crypto_dir"
          rm -rf "$crypto_dir"
        fi
      done

      if ! cryptsetup close "$container_name"; then
        errorinfo "($FUNCNAME) Associated device cannot be closed: /dev/mapper/$container_name"
        ret=1
      fi
    done
  done

  return $ret
}


function exec_inside() {
  local crypto_dir="$1"
  local command=${@:2}
  local ret

#  echo "$command"
  command='export SECD="'$crypto_dir'"; cd "$SECD"; '$command'; ret=$?; cd "'$current_dir'"; return $ret'
  eval "$command"
#  echo "$command"

  return $?
}


function getparam() {
  local param="$1"; shift
  local cryptfile="$1"
  local ret
  local found

  [ -z "$param" ] && return 1
  ret=1
  case "$param" in
  "CRYPT")
    [ -n "$cryptfile" ] && ret=0 && echo "$cryptfile"
    ;;
  *)
    while shift && [ "$ret" -eq 1 ] ; do
      case "$1" in
      "--init" | \
      "--open" | \
      "--close" | \
      "--exec" | \
      "--newreq" | \
      "--loadreq" | \
      "--loadtemplate" | \
      "--signserver" | \
      "--signclient" | \
      "--info" | \
      "--revoke" | \
      "--crl" | \
      "--export" )
        [ "$param" == "CMD" ] && ret=0 && echo "$1"
        ;;
      "--size" | \
      "--cmd" | \
      "--cn" | \
      "--internalname" | \
      "--file" | \
      "--dns" | \
      "--userid" | \
      "--serial" | \
      "--template" )
        [ "$param" == "$1" ] && shift && [ -n "$1" ] && ret=0 && echo "$1" || shift
        ;;
      "--help" | \
      "--nopass")
        [ "$param" == "$1" ] && ret=0
        ;;
      *)
        [ -z "$1" ] && continue
        echo "$1 - unknown parameter. Exit" >&2
        exit
        ;;
      esac
    done
    ;;
  esac

  return $ret
}


current_dir=$(dirname $(realpath -ms -- "$0"))

if [ $# -lt 1 ] || getparam "--help" "$@" ; then
  helpexit
fi
if ! pki_container=$(getparam "CRYPT" "$@") ; then
  errorinfo "Cryptfile is not specified"
  exit 1
fi
if ! command=$(getparam "CMD" "$@") ; then
  errorinfo "Not sure what you want me to do"
  exit 1
fi

case "$command" in
  "--init")
    pki_container=$(realpath -ms -- "$pki_container")
    if [ -e "$pki_container" ]; then
      errorinfo "File can not exist: $pki_container"
      exit 1
    fi

    container_size_mib=$(getparam "--size" "$@") || container_size_mib=12
    t=$(echo "$container_size_mib" | sed 's/[^0-9]//g')
    if [ "$t" != "$container_size_mib" ] ; then
      errorinfo "Size must be integer: $container_size_mib"
      exit 1
    fi

    if [ "$container_size_mib" -lt 8 ] ; then
      errorinfo "Size must be at least 8 MiB to fit journal: $container_size_mib"
      exit 1
    fi

    # add crypto headers to the size
    container_size_mib=$(( $container_size_mib +16 ))

    if ! dd if=/dev/urandom of="$pki_container" bs=1MiB count="$container_size_mib" &> /dev/null ; then
      errorinfo "Cannot create file: $pki_container"
      exit 1
    fi

    # keylen 32 for aes
    if ! container_key_txt=$(openssl rand 32 | base64 -w0) ; then
      rm -f "$pki_container"
      errorinfo "Cannot create key"
      exit 1
    fi

    if ! container_name=$(openssl rand -hex 8) ; then
      rm -f "$pki_container"
      errorinfo "Openssl rand error"
      exit 1
    fi

    if ! echo $container_key_txt | base64 -d | cryptsetup -q --cipher aes-cbc-essiv:sha256 --key-file - luksFormat "$pki_container" ; then
      rm -f "$pki_container"
      errorinfo "Cannot format new container: $pki_container"
      exit 1
    fi

    if ! echo $container_key_txt | base64 -d | cryptsetup open --type luks --key-file - "$pki_container" "$container_name" ; then
      rm -f "$pki_container"
      errorinfo "Cannot open new container: $pki_container"
      exit 1
    fi

    if ! mkfs.ext4 -q -m0 "/dev/mapper/$container_name" ; then
      cryptsetup close "$container_name"
      rm -f "$pki_container"
      errorinfo "Cannot format FS in the container: $pki_container"
      exit 1
    fi
    sync "/dev/mapper/$container_name" || sleep 5

    crypto_dir=$(mktemp -d /tmp/cptXXXXXX) && \
      rm -rf "$crypto_dir" && \
      mkdir -p "$crypto_dir" && \
      chmod 700 "$crypto_dir"
    if [ $? -ne 0 ]; then
      cryptsetup close "$container_name"
      rm -f "$pki_container"
      errorinfo "Cannot create temp mountpoint: $crypto_dir"
      exit 1
    fi

    if ! mount -o sync "/dev/mapper/$container_name" "$crypto_dir" ; then
      rm -rf "$crypto_dir"
      cryptsetup close "$container_name"
      rm -f "$pki_container"
      errorinfo "Cannot mount container $pki_container to $crypto_dir"
      exit 1
    fi
    chmod 700 "$crypto_dir"

    ret=0
    [ $ret -eq 0 ] && cp -a /usr/share/easy-rsa "$crypto_dir" && \
      cp "$crypto_dir/easy-rsa/vars.example" "$crypto_dir/easy-rsa/vars" && \
      cat << VARS >> "$crypto_dir/easy-rsa/vars"
set_var EASYRSA_BATCH       Yes
set_var EASYRSA_ALGO        ec
set_var EASYRSA_DIGEST      "sha512"
set_var EASYRSA_DN          "org"
set_var EASYRSA_REQ_COUNTRY ""
set_var EASYRSA_REQ_PROVINCE ""
set_var EASYRSA_REQ_CITY    ""
set_var EASYRSA_REQ_ORG     ""
set_var EASYRSA_REQ_EMAIL   ""
set_var EASYRSA_REQ_OU      ""
VARS
    [ $? -ne 0 ] && ret=1 && errorinfo "Cannot write into container: $pki_container"

    [ $ret -eq 0 ] && ! sed 's/commonName[\t ]\+=[\t ]\+supplied/commonName\t= optional/' -i "$crypto_dir/easy-rsa/openssl-easyrsa.cnf" && ret=1 && errorinfo "Cannot make commonName optional"
    [ $ret -eq 0 ] && ! mkdir -p "$crypto_dir/templates" && ret=1 && errorinfo "Cannot create templates dir"
    [ $ret -eq 0 ] && ! openvpn --genkey secret "$crypto_dir/pki/ta.key" && ret=1 && errorinfo "Cannot create TA secret"

    [ $ret -eq 0 ] && ! "$crypto_dir/easy-rsa/easyrsa" --pki-dir="$crypto_dir/pki" init-pki >&2 && \
      ret=1 && errorinfo "Easyrsa cannot init in container: $pki_container"

    sync "/dev/mapper/$container_name" || sleep 5
    umount -l "/dev/mapper/$container_name"
    rm -rf "$crypto_dir"
    cryptsetup close "$container_name"

    if [ $ret -eq 0 ] ; then
      echo "$container_key_txt"
    else
      rm -f "$pki_container"
    fi
    exit $ret
    ;;

  "--open")
    close_container "$pki_container" || exit 1
    crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY") || exit 1
    echo "$crypto_dir"
    exit 0
    ;;

  "--close")
    close_container "$pki_container" || exit 1
    exit 0
    ;;

  "--loadreq")
    if ! load_file=$(getparam "--file" "$@") ; then
      errorinfo "No file to load"
      exit 1
    fi

    load_file=$(realpath -ms -- "$load_file")
    if [ ! -f "$load_file" ]; then
      errorinfo "File does not exists: $load_file"
      return 1
    fi

    if ! internalname=$(getparam "--internalname" "$@") ; then
      internalname="$(basename \"$load_file\" | sed 's/\.[^\.]*$//')"
      if [ -z "$internalname" ] || [ "$internalname" == "ca" ]; then
        errorinfo "Inappropriate internalname"
        exit 1
      fi
    fi

    close_container "$pki_container" || exit 1
    crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY") || exit 1

    ret=0
    if [ -f "$crypto_dir/pki/private/${internalname}.key" ] || [ -f "$crypto_dir/pki/issued/${internalname}.crt" ] ; then
      ret=1
      errorinfo "Internalname is occupied: $internalname"
    fi

    [ $ret -eq 0 ] && cp -f "$load_file" "$crypto_dir/pki/reqs/${internalname}.req" || ret=1
    close_container "$pki_container" || ret=1

    exit $ret
    ;;

  "--newreq")
    if ! internalname=$(getparam "--internalname" "$@") || [ "$internalname" == "ca" ] ; then
      errorinfo "Incorrect internalname. Can not be empty or \"ca\""
      exit 1
    fi

    cn_name=$(getparam "--cn" "$@") || cn_name="$internalname"

    nopass=""
    getparam "--nopass" "$@" && nopass="nopass"

    if ! close_container "$pki_container"; then
      exit 1
    fi

    if ! crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY"); then
      exit 1
    fi

    ret=0
    if [ -f "$crypto_dir/pki/private/${internalname}.key" ] || [ -f "$crypto_dir/pki/issued/${internalname}.crt" ] ; then
      ret=1
      errorinfo "internalname is occupied: $internalname"
    fi
    if [ $ret -eq 0 ]; then
      rm -f "$crypto_dir/pki/reqs/${internalname}.req"
      exec_inside "$crypto_dir" "easy-rsa/easyrsa --req-cn=\"$cn_name\" gen-req \"$internalname\" $nopass" || ret=1
    fi
    close_container "$pki_container" || ret=1

    exit $ret
    ;;

  "--signserver")
    if ! internalname=$(getparam "--internalname" "$@") || [ "$internalname" == "ca" ] ; then
      errorinfo "Incorrect internalname. Can not be empty or \"ca\""
      exit 1
    fi

    userid=$(getparam "--userid" "$@") || userid="$internalname"
    dnsname=$(getparam "--dns" "$@") || dnsname="$internalname"

    if ! close_container "$pki_container"; then
      exit 1
    fi

    if ! crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY"); then
      exit 1
    fi

    ret=0
    if [ ! -f "$crypto_dir/pki/reqs/${internalname}.req" ] ; then
      ret=1
      errorinfo "No such a request: ${internalname}.req"
    fi
    if [ $ret -eq 0 ] && [ -f "$crypto_dir/pki/issued/${internalname}.crt" ] ; then
      ret=1
      errorinfo "Cert with this internalname have already been issued: ${internalname}"
    fi

    if [ $ret -eq 0 ]; then
      exec_inside "$crypto_dir" "easy-rsa/easyrsa --subject-alt-name='DNS:$dnsname,email:$userid' sign-req server $internalname" || ret=1
    fi

    close_container "$pki_container" || ret=1

    exit $ret
  ;;

  "--signclient")
    if ! internalname=$(getparam "--internalname" "$@") || [ "$internalname" == "ca" ] ; then
      errorinfo "Incorrect internalname. Can not be empty or \"ca\""
      exit 1
    fi

    userid=$(getparam "--userid" "$@") || userid="$internalname"
    dnsname=$(getparam "--dns" "$@") || dnsname=""

    if ! close_container "$pki_container"; then
      exit 1
    fi

    if ! crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY"); then
      exit 1
    fi

    ret=0
    if [ ! -f "$crypto_dir/pki/reqs/${internalname}.req" ] ; then
      ret=1
      errorinfo "No such a request: ${internalname}.req"
    fi
    if [ $ret -eq 0 ] && [ -f "$crypto_dir/pki/issued/${internalname}.crt" ] ; then
      ret=1
      errorinfo "Cert with this internalname have already been issued: ${internalname}"
    fi
    if [ $ret -eq 0 ]; then
      [ -n "$dnsname" ] && dnsname="DNS:${dnsname},"
      exec_inside "$crypto_dir" "easy-rsa/easyrsa --subject-alt-name='${dnsname}email:$userid' sign-req client $internalname" || ret=1
    fi
    close_container "$pki_container" || ret=1

    exit $ret
  ;;

  "--exec")
    if ! cmd=$(getparam "--cmd" "$@") ; then
      errorinfo "Command is not specified"
      exit 1
    fi

    if ! close_container "$pki_container"; then
      exit 1
    fi

    if ! crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY"); then
      exit 1
    fi

    ret=0
    exec_inside "$crypto_dir" "$cmd" || ret=1
    close_container "$pki_container" || ret=1

    exit $ret
  ;;

  "--info")
    internalname=$(getparam "--internalname" "$@")
    serial=$(getparam "--serial" "$@")
    if ([ -n "$internalname" ] && [ -n "$serial" ]) || ([ -z "$internalname" ] && [ -z "$serial" ]); then
      errorinfo "Only one of internalname or serial must be specified"
      exit 1
    fi

    if ! close_container "$pki_container"; then
      exit 1
    fi

    if ! crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY"); then
      exit 1
    fi

    ret=0
    cert_file=""
    if [ -n "$serial" ] ; then
      cert_file="$crypto_dir/pki/certs_by_serial/${serial^^}.pem"
    elif [ -n "$internalname" ] ; then
      cert_file="$crypto_dir/pki/issued/${internalname}.crt"
    else
      ret=1
      errorinfo "impossible for now"
    fi

    if [ ! -f "$cert_file" ] ; then
      ret=1
      errorinfo "No such file: $cert_file"
    fi

    [ $ret -eq 0 ] && openssl x509 -in "$cert_file" -noout -text || ret=1
    close_container "$pki_container" || ret=1

    exit $ret
  ;;

  "--revoke")
    if ! internalname=$(getparam "--internalname" "$@"); then
      errorinfo "Need internalname to revoke"
      exit 1
    fi

    if ! crl_file=$(getparam "--file" "$@"); then
      errorinfo "Where to export the new CRL?"
      exit 1
    fi
    crl_file=$(realpath -ms -- "$crl_file")
    if ! mkdir -p $(dirname "$crl_file") || ! touch "$crl_file" || [ ! -w "$crl_file" ] || [ ! -f "$crl_file" ] ; then
      errorinfo "Cannot write CRL in file: $crl_file"
      exit 1
    fi

    if ! close_container "$pki_container"; then
      exit 1
    fi

    if ! crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY"); then
      exit 1
    fi

    ret=0
    exec_inside "$crypto_dir" "easy-rsa/easyrsa revoke $internalname" || ret=1
    exec_inside "$crypto_dir" "easy-rsa/easyrsa gen-crl" || ret=1
    exec_inside "$crypto_dir" "cp -f pki/crl.pem \"$crl_file\"" || ret=1
    close_container "$pki_container" || ret=1

    exit $ret
  ;;

  "--crl")
    if ! crl_file=$(getparam "--file" "$@"); then
      errorinfo "Where to export the new CRL?"
      exit 1
    fi
    crl_file=$(realpath -ms -- "$crl_file")
    if ! mkdir -p $(dirname "$crl_file") || ! touch "$crl_file" || [ ! -w "$crl_file" ] || [ ! -f "$crl_file" ] ; then
      errorinfo "Cannot write CRL in file: $crl_file"
      exit 1
    fi

    if ! close_container "$pki_container"; then
      exit 1
    fi

    if ! crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY"); then
      exit 1
    fi

    ret=0
    exec_inside "$crypto_dir" "easy-rsa/easyrsa gen-crl" || ret=1
    exec_inside "$crypto_dir" "cp -f pki/crl.pem \"$crl_file\"" || ret=1
    close_container "$pki_container" || ret=1

    exit $ret
  ;;

  "--loadtemplate")
    if ! load_file=$(getparam "--file" "$@") ; then
      errorinfo "No file to load"
      exit 1
    fi

    load_file=$(realpath -ms -- "$load_file")
    if [ ! -f "$load_file" ]; then
      errorinfo "File does not exists: $load_file"
      return 1
    fi

    close_container "$pki_container" || exit 1
    crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY") || exit 1

    ret=0
    cp -f "$load_file" "$crypto_dir/templates/" || ret=1
    close_container "$pki_container" || ret=1

    exit $ret
    ;;

  "--export")
    if ! internalname=$(getparam "--internalname" "$@") || [ "$internalname" == "ca" ] ; then
      errorinfo "Incorrect internalname. Can not be empty or \"ca\""
      exit 1
    fi

    if ! export_file=$(getparam "--file" "$@"); then
      errorinfo "Where to export?"
      exit 1
    fi
    export_file=$(realpath -ms -- "$export_file")
    if ! mkdir -p $(dirname "$export_file") || ! touch "$export_file" || [ ! -w "$export_file" ] || [ ! -f "$export_file" ] ; then
      errorinfo "Cannot write in file: $export_file"
      exit 1
    fi

    template=$(getparam "--template" "$@") || template=""

    if ! close_container "$pki_container"; then
      exit 1
    fi

    if ! crypto_dir=$(open_container "$pki_container" "$CONTAINER_KEY"); then
      exit 1
    fi

    nokey="nokey"
    [ -f "$crypto_dir/pki/private/${internalname}.key" ] && nokey=""

    ret=0
    if [ -z "$template" ]; then

      exec_inside "$crypto_dir" "easy-rsa/easyrsa export-p12 $internalname $nokey" || ret=1
    elif [ -f "$crypto_dir/templates/$template" ] && [ -f "$crypto_dir/pki/issued/${internalname}.crt" ] ; then

      export SUBSTKEYNAME="$internalname"
      export SUBSTCA=$(echo -e "<ca>\n$(cat "$crypto_dir/pki/ca.crt")\n</ca>")  #"
      export SUBSTTLS=$(echo -e "<tls-crypt>\n$(cat "$crypto_dir/pki/ta.key")\n</tls-crypt>")  #"
      export SUBSTCERT=$(echo -e "<cert>\n$(cat "$crypto_dir/pki/issued/${internalname}.crt")\n</cert>")  #"
      envsubst < "$crypto_dir/templates/$template" > "$export_file" || ret=1
    else
      ret=1
      errorinfo "No such template: $template"
    fi
    close_container "$pki_container" || ret=1

    exit $ret
  ;;


  *)
    errorinfo "No command given"
    exit 1
    ;;
esac
